import * as tslib_1 from "tslib";
import { Component, ComponentFactoryResolver, ElementRef, Inject, Type, ViewContainerRef, ViewChild, } from '@angular/core';
import { of } from 'rxjs';
import { DefaultSimpleModalOptionConfig, } from './simple-modal-options';
import { SimpleModalWrapperComponent } from './simple-modal-wrapper.component';
/**
 * View container manager which manages a list of modals currently active
 * inside the viewvontainer
 */
var SimpleModalHolderComponent = /** @class */ (function () {
    /**
     * Constructor
     * @param {ComponentFactoryResolver} resolver
     */
    function SimpleModalHolderComponent(resolver, defaultSimpleModalOptions) {
        this.resolver = resolver;
        this.defaultSimpleModalOptions = defaultSimpleModalOptions;
        /**
         * modal collection, maintained by addModal and removeModal
         * @type {Array<SimpleModalComponent> }
         */
        this.modals = [];
        /**
         * if auto focus is on and no element focused, store it here to be restored back after close
         */
        this.previousActiveElement = null;
    }
    /**
     * Configures then adds modal to the modals array, and populates with data passed in
     * @param {Type<SimpleModalComponent>} component
     * @param {object?} data
     * @param {SimpleModalOptionsOverrides?} options
     * @return {Observable<*>}
     */
    SimpleModalHolderComponent.prototype.addModal = function (component, data, options) {
        var _this = this;
        // create component
        if (!this.viewContainer) {
            return of(null);
        }
        var factory = this.resolver.resolveComponentFactory(SimpleModalWrapperComponent);
        var componentRef = this.viewContainer.createComponent(factory);
        var modalWrapper = (componentRef.instance);
        var _component = modalWrapper.addComponent(component);
        // assign options refs
        _component.options = options = Object.assign({}, this.defaultSimpleModalOptions, options);
        // set base classes for wrapper
        modalWrapper.modalClasses = options.wrapperDefaultClasses;
        // add to stack
        this.modals.push(_component);
        // wait a tick then setup the following while adding a modal
        this.wait().then(function () {
            _this.toggleWrapperClass(modalWrapper.wrapper, options.wrapperClass);
            _this.toggleBodyClass(options.bodyClass);
            _this.wait(options.animationDuration).then(function () {
                _this.autoFocusFirstElement(_component.wrapper, options.autoFocus);
                _component.markAsReady();
            });
        });
        // when closing modal remove it
        _component.onClosing(function (modal) { return _this.removeModal(modal); });
        // if clicking on background closes modal
        this.configureCloseOnClickOutside(modalWrapper);
        // map and return observable
        _component.mapDataObject(data);
        return _component.setupObserver();
    };
    /**
     * triggers components close function
     * to take effect
     * @param {SimpleModalComponent} component
     * @returns {Promise<void>}
     */
    SimpleModalHolderComponent.prototype.removeModal = function (closingModal) {
        var _this = this;
        var options = closingModal.options;
        this.toggleWrapperClass(closingModal.wrapper, options.wrapperClass);
        return this.wait(options.animationDuration).then(function () {
            _this.removeModalFromArray(closingModal);
            _this.toggleBodyClass(options.bodyClass);
            _this.restorePreviousFocus();
        });
    };
    /**
     * Instructs all open modals to
     */
    SimpleModalHolderComponent.prototype.removeAllModals = function () {
        var _this = this;
        return Promise.all(this.modals.map(function (modal) { return _this.removeModal(modal); }));
    };
    /**
     * Bind a body class 'modal-open' to a condition of modals in pool > 0
     * @param bodyClass - string to add and remove from body in document
     */
    SimpleModalHolderComponent.prototype.toggleBodyClass = function (bodyClass) {
        var _a, _b;
        if (!bodyClass) {
            return;
        }
        var body = document.getElementsByTagName('body')[0];
        var bodyClassItems = bodyClass.split(' ');
        if (!this.modals.length) {
            (_a = body.classList).remove.apply(_a, tslib_1.__spread(bodyClassItems));
        }
        else {
            (_b = body.classList).add.apply(_b, tslib_1.__spread(bodyClassItems));
        }
    };
    /**
     * if the option to close on background click is set, then hook up a callback
     * @param options
     * @param modalWrapper
     */
    SimpleModalHolderComponent.prototype.configureCloseOnClickOutside = function (modalWrapper) {
        if (modalWrapper.content.options.closeOnClickOutside) {
            modalWrapper.onClickOutsideModalContent(function () {
                modalWrapper.content.close();
            });
        }
    };
    /**
     * Auto focus o the first element if autofocus is on
     * @param options
     * @param modalWrapperEl
     */
    SimpleModalHolderComponent.prototype.autoFocusFirstElement = function (componentWrapper, autoFocus) {
        if (autoFocus) {
            var focusable = componentWrapper.nativeElement.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
            if (focusable && focusable.length) {
                this.previousActiveElement = document.activeElement;
                focusable[0].focus();
            }
        }
    };
    /**
     * Restores the last focus is there was one
     */
    SimpleModalHolderComponent.prototype.restorePreviousFocus = function () {
        if (this.previousActiveElement) {
            this.previousActiveElement.focus();
            this.previousActiveElement = null;
        }
    };
    /**
     * Configure the adding and removal of a wrapper class - predominantly animation focused
     * @param options
     * @param modalWrapperEl
     */
    SimpleModalHolderComponent.prototype.toggleWrapperClass = function (modalWrapperEl, wrapperClass) {
        var wrapperClassList = modalWrapperEl.nativeElement.classList;
        var wrapperClassItems = wrapperClass.split(' ');
        if (wrapperClassList.toString().indexOf(wrapperClass) !== -1) {
            wrapperClassList.remove.apply(wrapperClassList, tslib_1.__spread(wrapperClassItems));
        }
        else {
            wrapperClassList.add.apply(wrapperClassList, tslib_1.__spread(wrapperClassItems));
        }
    };
    /**
     * Helper function for a more readable timeout
     * @param ms
     */
    SimpleModalHolderComponent.prototype.wait = function (ms) {
        if (ms === void 0) { ms = 0; }
        return new Promise(function (resolve, reject) {
            setTimeout(function () { return resolve(); }, ms);
        });
    };
    /**
     * Instructs the holder to remove the modal and
     * removes this component from the collection
     * @param {SimpleModalComponent} component
     */
    SimpleModalHolderComponent.prototype.removeModalFromArray = function (component) {
        var index = this.modals.indexOf(component);
        if (index > -1) {
            this.viewContainer.remove(index);
            this.modals.splice(index, 1);
        }
    };
    SimpleModalHolderComponent.ctorParameters = function () { return [
        { type: ComponentFactoryResolver },
        { type: undefined, decorators: [{ type: Inject, args: [DefaultSimpleModalOptionConfig,] }] }
    ]; };
    tslib_1.__decorate([
        ViewChild('viewContainer', { read: ViewContainerRef, static: true })
    ], SimpleModalHolderComponent.prototype, "viewContainer", void 0);
    SimpleModalHolderComponent = tslib_1.__decorate([
        Component({
            selector: 'simple-modal-holder',
            template: '<ng-template #viewContainer></ng-template>'
        }),
        tslib_1.__param(1, Inject(DefaultSimpleModalOptionConfig))
    ], SimpleModalHolderComponent);
    return SimpleModalHolderComponent;
}());
export { SimpleModalHolderComponent };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2ltcGxlLW1vZGFsLWhvbGRlci5jb21wb25lbnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtc2ltcGxlLW1vZGFsLyIsInNvdXJjZXMiOlsic2ltcGxlLW1vZGFsL3NpbXBsZS1tb2RhbC1ob2xkZXIuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQ0wsU0FBUyxFQUNULHdCQUF3QixFQUN4QixVQUFVLEVBQ1YsTUFBTSxFQUNOLElBQUksRUFDSixnQkFBZ0IsRUFDaEIsU0FBUyxHQUNWLE1BQU0sZUFBZSxDQUFDO0FBQ3ZCLE9BQU8sRUFBYyxFQUFFLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdEMsT0FBTyxFQUNMLDhCQUE4QixHQUcvQixNQUFNLHdCQUF3QixDQUFDO0FBQ2hDLE9BQU8sRUFBRSwyQkFBMkIsRUFBRSxNQUFNLGtDQUFrQyxDQUFDO0FBRy9FOzs7R0FHRztBQUtIO0lBaUJFOzs7T0FHRztJQUNILG9DQUNVLFFBQWtDLEVBQ00seUJBQTZDO1FBRHJGLGFBQVEsR0FBUixRQUFRLENBQTBCO1FBQ00sOEJBQXlCLEdBQXpCLHlCQUF5QixDQUFvQjtRQWpCL0Y7OztXQUdHO1FBQ0gsV0FBTSxHQUEwQyxFQUFFLENBQUM7UUFFbkQ7O1dBRUc7UUFDSCwwQkFBcUIsR0FBRyxJQUFJLENBQUM7SUFTMUIsQ0FBQztJQUVKOzs7Ozs7T0FNRztJQUNILDZDQUFRLEdBQVIsVUFDRSxTQUE0QyxFQUM1QyxJQUFRLEVBQ1IsT0FBcUM7UUFIdkMsaUJBNkNDO1FBeENDLG1CQUFtQjtRQUNuQixJQUFJLENBQUMsSUFBSSxDQUFDLGFBQWEsRUFBRTtZQUN2QixPQUFPLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztTQUNqQjtRQUNELElBQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUMsdUJBQXVCLENBQUMsMkJBQTJCLENBQUMsQ0FBQztRQUNuRixJQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFD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QUUsRUFBRSxJQUFJLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxFQUFFLElBQUksRUFBRSxDQUFDO3FFQUFlO0lBSnpFLDBCQUEwQjtRQUp0QyxTQUFTLENBQUM7WUFDVCxRQUFRLEVBQUUscUJBQXFCO1lBQy9CLFFBQVEsRUFBRSw0Q0FBNEM7U0FDdkQsQ0FBQztRQXdCRyxtQkFBQSxNQUFNLENBQUMsOEJBQThCLENBQUMsQ0FBQTtPQXZCOUIsMEJBQTBCLENBcU10QztJQUFELGlDQUFDO0NBQUEsQUFyTUQsSUFxTUM7U0FyTVksMEJBQTBCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcclxuICBDb21wb25lbnQsXHJcbiAgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLFxyXG4gIEVsZW1lbnRSZWYsXHJcbiAgSW5qZWN0LFxyXG4gIFR5cGUsXHJcbiAgVmlld0NvbnRhaW5lclJlZixcclxuICBWaWV3Q2hpbGQsXHJcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcbmltcG9ydCB7IE9ic2VydmFibGUsIG9mIH0gZnJvbSAncnhqcyc7XHJcbmltcG9ydCB7XHJcbiAgRGVmYXVsdFNpbXBsZU1vZGFsT3B0aW9uQ29uZmlnLFxyXG4gIFNpbXBsZU1vZGFsT3B0aW9ucyxcclxuICBTaW1wbGVNb2RhbE9wdGlvbnNPdmVycmlkZXMsXHJcbn0gZnJvbSAnLi9zaW1wbGUtbW9kYWwtb3B0aW9ucyc7XHJcbmltcG9ydCB7IFNpbXBsZU1vZGFsV3JhcHBlckNvbXBvbmVudCB9IGZyb20gJy4vc2ltcGxlLW1vZGFsLXdyYXBwZXIuY29tcG9uZW50JztcclxuaW1wb3J0IHsgU2ltcGxlTW9kYWxDb21wb25lbnQgfSBmcm9tICcuL3NpbXBsZS1tb2RhbC5jb21wb25lbnQnO1xyXG5cclxuLyoqXHJcbiAqIFZpZXcgY29udGFpbmVyIG1hbmFnZXIgd2hpY2ggbWFuYWdlcyBhIGxpc3Qgb2YgbW9kYWxzIGN1cnJlbnRseSBhY3RpdmVcclxuICogaW5zaWRlIHRoZSB2aWV3dm9udGFpbmVyXHJcbiAqL1xyXG5AQ29tcG9uZW50KHtcclxuICBzZWxlY3RvcjogJ3NpbXBsZS1tb2RhbC1ob2xkZXInLFxyXG4gIHRlbXBsYXRlOiAnPG5nLXRlbXBsYXRlICN2aWV3Q29udGFpbmVyPjwvbmctdGVtcGxhdGU+JyxcclxufSlcclxuZXhwb3J0IGNsYXNzIFNpbXBsZU1vZGFsSG9sZGVyQ29tcG9uZW50IHtcclxuICAvKipcclxuICAgKiBUYXJnZXQgdmlld0NvbnRhaW5lciB0byBpbnNlcnQgbW9kYWxzXHJcbiAgICovXHJcbiAgQFZpZXdDaGlsZCgndmlld0NvbnRhaW5lcicsIHsgcmVhZDogVmlld0NvbnRhaW5lclJlZiwgc3RhdGljOiB0cnVlIH0pIHZpZXdDb250YWluZXI7XHJcblxyXG4gIC8qKlxyXG4gICAqIG1vZGFsIGNvbGxlY3Rpb24sIG1haW50YWluZWQgYnkgYWRkTW9kYWwgYW5kIHJlbW92ZU1vZGFsXHJcbiAgICogQHR5cGUge0FycmF5PFNpbXBsZU1vZGFsQ29tcG9uZW50PiB9XHJcbiAgICovXHJcbiAgbW9kYWxzOiBBcnJheTxTaW1wbGVNb2RhbENvbXBvbmVudDxhbnksIGFueT4+ID0gW107XHJcblxyXG4gIC8qKlxyXG4gICAqIGlmIGF1dG8gZm9jdXMgaXMgb24gYW5kIG5vIGVsZW1lbnQgZm9jdXNlZCwgc3RvcmUgaXQgaGVyZSB0byBiZSByZXN0b3JlZCBiYWNrIGFmdGVyIGNsb3NlXHJcbiAgICovXHJcbiAgcHJldmlvdXNBY3RpdmVFbGVtZW50ID0gbnVsbDtcclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RydWN0b3JcclxuICAgKiBAcGFyYW0ge0NvbXBvbmVudEZhY3RvcnlSZXNvbHZlcn0gcmVzb2x2ZXJcclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIHByaXZhdGUgcmVzb2x2ZXI6IENvbXBvbmVudEZhY3RvcnlSZXNvbHZlcixcclxuICAgIEBJbmplY3QoRGVmYXVsdFNpbXBsZU1vZGFsT3B0aW9uQ29uZmlnKSBwcml2YXRlIGRlZmF1bHRTaW1wbGVNb2RhbE9wdGlvbnM6IFNpbXBsZU1vZGFsT3B0aW9uc1xyXG4gICkge31cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uZmlndXJlcyB0aGVuIGFkZHMgbW9kYWwgdG8gdGhlIG1vZGFscyBhcnJheSwgYW5kIHBvcHVsYXRlcyB3aXRoIGRhdGEgcGFzc2VkIGluXHJcbiAgICogQHBhcmFtIHtUeXBlPFNpbXBsZU1vZGFsQ29tcG9uZW50Pn0gY29tcG9uZW50XHJcbiAgICogQHBhcmFtIHtvYmplY3Q/fSBkYXRhXHJcbiAgICogQHBhcmFtIHtTaW1wbGVNb2RhbE9wdGlvbnNPdmVycmlkZXM/fSBvcHRpb25zXHJcbiAgICogQHJldHVybiB7T2JzZXJ2YWJsZTwqPn1cclxuICAgKi9cclxuICBhZGRNb2RhbDxULCBUMT4oXHJcbiAgICBjb21wb25lbnQ6IFR5cGU8U2ltcGxlTW9kYWxDb21wb25lbnQ8VCwgVDE+PixcclxuICAgIGRhdGE/OiBULFxyXG4gICAgb3B0aW9ucz86IFNpbXBsZU1vZGFsT3B0aW9uc092ZXJyaWRlc1xyXG4gICk6IE9ic2VydmFibGU8VDE+IHtcclxuICAgIC8vIGNyZWF0ZSBjb21wb25lbnRcclxuICAgIGlmICghdGhpcy52aWV3Q29udGFpbmVyKSB7XHJcbiAgICAgIHJldHVybiBvZihudWxsKTtcclxuICAgIH1cclxuICAgIGNvbnN0IGZhY3RvcnkgPSB0aGlzLnJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KFNpbXBsZU1vZGFsV3JhcHBlckNvbXBvbmVudCk7XHJcbiAgICBjb25zdCBjb21wb25lbnRSZWYgPSB0aGlzLnZpZXdDb250YWluZXIuY3JlYXRlQ29tcG9uZW50KGZhY3RvcnkpO1xyXG4gICAgY29uc3QgbW9kYWxXcmFwcGVyOiBTaW1wbGVNb2RhbFdyYXBwZXJDb21wb25lbnQgPSA8U2ltcGxlTW9kYWxXcmFwcGVyQ29tcG9uZW50PihcclxuICAgICAgY29tcG9uZW50UmVmLmluc3RhbmNlXHJcbiAgICApO1xyXG4gICAgY29uc3QgX2NvbXBvbmVudDogU2ltcGxlTW9kYWxDb21wb25lbnQ8VCwgVDE+ID0gbW9kYWxXcmFwcGVyLmFkZENvbXBvbmVudChjb21wb25lbnQpO1xyXG5cclxuICAgIC8vIGFzc2lnbiBvcHRpb25zIHJlZnNcclxuICAgIF9jb21wb25lbnQub3B0aW9ucyA9IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmRlZmF1bHRTaW1wbGVNb2RhbE9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cclxuICAgIC8vIHNldCBiYXNlIGNsYXNzZXMgZm9yIHdyYXBwZXJcclxuICAgIG1vZGFsV3JhcHBlci5tb2RhbENsYXNzZXMgPSBvcHRpb25zLndyYXBwZXJEZWZhdWx0Q2xhc3NlcztcclxuXHJcbiAgICAvLyBhZGQgdG8gc3RhY2tcclxuICAgIHRoaXMubW9kYWxzLnB1c2goX2NvbXBvbmVudCk7XHJcblxyXG4gICAgLy8gd2FpdCBhIHRpY2sgdGhlbiBzZXR1cCB0aGUgZm9sbG93aW5nIHdoaWxlIGFkZGluZyBhIG1vZGFsXHJcbiAgICB0aGlzLndhaXQoKS50aGVuKCgpID0+IHtcclxuICAgICAgdGhpcy50b2dnbGVXcmFwcGVyQ2xhc3MobW9kYWxXcmFwcGVyLndyYXBwZXIsIG9wdGlvbnMud3JhcHBlckNsYXNzKTtcclxuICAgICAgdGhpcy50b2dnbGVCb2R5Q2xhc3Mob3B0aW9ucy5ib2R5Q2xhc3MpO1xyXG4gICAgICB0aGlzLndhaXQob3B0aW9ucy5hbmltYXRpb25EdXJhdGlvbikudGhlbigoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5hdXRvRm9jdXNGaXJzdEVsZW1lbnQoX2NvbXBvbmVudC53cmFwcGVyLCBvcHRpb25zLmF1dG9Gb2N1cyk7XHJcbiAgICAgICAgX2NvbXBvbmVudC5tYXJrQXNSZWFkeSgpO1xyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIHdoZW4gY2xvc2luZyBtb2RhbCByZW1vdmUgaXRcclxuICAgIF9jb21wb25lbnQub25DbG9zaW5nKG1vZGFsID0+IHRoaXMucmVtb3ZlTW9kYWwobW9kYWwpKTtcclxuXHJcbiAgICAvLyBpZiBjbGlja2luZyBvbiBiYWNrZ3JvdW5kIGNsb3NlcyBtb2RhbFxyXG4gICAgdGhpcy5jb25maWd1cmVDbG9zZU9uQ2xpY2tPdXRzaWRlKG1vZGFsV3JhcHBlcik7XHJcblxyXG4gICAgLy8gbWFwIGFuZCByZXR1cm4gb2JzZXJ2YWJsZVxyXG4gICAgX2NvbXBvbmVudC5tYXBEYXRhT2JqZWN0KGRhdGEpO1xyXG5cclxuICAgIHJldHVybiBfY29tcG9uZW50LnNldHVwT2JzZXJ2ZXIoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIHRyaWdnZXJzIGNvbXBvbmVudHMgY2xvc2UgZnVuY3Rpb25cclxuICAgKiB0byB0YWtlIGVmZmVjdFxyXG4gICAqIEBwYXJhbSB7U2ltcGxlTW9kYWxDb21wb25lbnR9IGNvbXBvbmVudFxyXG4gICAqIEByZXR1cm5zIHtQcm9taXNlPHZvaWQ+fVxyXG4gICAqL1xyXG4gIHJlbW92ZU1vZGFsKGNsb3NpbmdNb2RhbDogU2ltcGxlTW9kYWxDb21wb25lbnQ8YW55LCBhbnk+KTogUHJvbWlzZTxhbnk+IHtcclxuICAgIGNvbnN0IG9wdGlvbnMgPSBjbG9zaW5nTW9kYWwub3B0aW9ucztcclxuICAgIHRoaXMudG9nZ2xlV3JhcHBlckNsYXNzKGNsb3NpbmdNb2RhbC53cmFwcGVyLCBvcHRpb25zLndyYXBwZXJDbGFzcyk7XHJcbiAgICByZXR1cm4gdGhpcy53YWl0KG9wdGlvbnMuYW5pbWF0aW9uRHVyYXRpb24pLnRoZW4oKCkgPT4ge1xyXG4gICAgICB0aGlzLnJlbW92ZU1vZGFsRnJvbUFycmF5KGNsb3NpbmdNb2RhbCk7XHJcbiAgICAgIHRoaXMudG9nZ2xlQm9keUNsYXNzKG9wdGlvbnMuYm9keUNsYXNzKTtcclxuICAgICAgdGhpcy5yZXN0b3JlUHJldmlvdXNGb2N1cygpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbnN0cnVjdHMgYWxsIG9wZW4gbW9kYWxzIHRvXHJcbiAgICovXHJcbiAgcmVtb3ZlQWxsTW9kYWxzKCk6IFByb21pc2U8YW55PiB7XHJcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwodGhpcy5tb2RhbHMubWFwKG1vZGFsID0+IHRoaXMucmVtb3ZlTW9kYWwobW9kYWwpKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBCaW5kIGEgYm9keSBjbGFzcyAnbW9kYWwtb3BlbicgdG8gYSBjb25kaXRpb24gb2YgbW9kYWxzIGluIHBvb2wgPiAwXHJcbiAgICogQHBhcmFtIGJvZHlDbGFzcyAtIHN0cmluZyB0byBhZGQgYW5kIHJlbW92ZSBmcm9tIGJvZHkgaW4gZG9jdW1lbnRcclxuICAgKi9cclxuICBwcml2YXRlIHRvZ2dsZUJvZHlDbGFzcyhib2R5Q2xhc3M6IHN0cmluZykge1xyXG4gICAgaWYgKCFib2R5Q2xhc3MpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgYm9keSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07XHJcbiAgICBjb25zdCBib2R5Q2xhc3NJdGVtcyA9IGJvZHlDbGFzcy5zcGxpdCgnICcpO1xyXG4gICAgaWYgKCF0aGlzLm1vZGFscy5sZW5ndGgpIHtcclxuICAgICAgYm9keS5jbGFzc0xpc3QucmVtb3ZlKC4uLmJvZHlDbGFzc0l0ZW1zKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGJvZHkuY2xhc3NMaXN0LmFkZCguLi5ib2R5Q2xhc3NJdGVtcyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBpZiB0aGUgb3B0aW9uIHRvIGNsb3NlIG9uIGJhY2tncm91bmQgY2xpY2sgaXMgc2V0LCB0aGVuIGhvb2sgdXAgYSBjYWxsYmFja1xyXG4gICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICogQHBhcmFtIG1vZGFsV3JhcHBlclxyXG4gICAqL1xyXG4gIHByaXZhdGUgY29uZmlndXJlQ2xvc2VPbkNsaWNrT3V0c2lkZShtb2RhbFdyYXBwZXI6IFNpbXBsZU1vZGFsV3JhcHBlckNvbXBvbmVudCkge1xyXG4gICAgaWYgKG1vZGFsV3JhcHBlci5jb250ZW50Lm9wdGlvbnMuY2xvc2VPbkNsaWNrT3V0c2lkZSkge1xyXG4gICAgICBtb2RhbFdyYXBwZXIub25DbGlja091dHNpZGVNb2RhbENvbnRlbnQoKCkgPT4ge1xyXG4gICAgICAgIG1vZGFsV3JhcHBlci5jb250ZW50LmNsb3NlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXV0byBmb2N1cyBvIHRoZSBmaXJzdCBlbGVtZW50IGlmIGF1dG9mb2N1cyBpcyBvblxyXG4gICAqIEBwYXJhbSBvcHRpb25zXHJcbiAgICogQHBhcmFtIG1vZGFsV3JhcHBlckVsXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBhdXRvRm9jdXNGaXJzdEVsZW1lbnQoY29tcG9uZW50V3JhcHBlcjogRWxlbWVudFJlZiwgYXV0b0ZvY3VzOiBib29sZWFuKSB7XHJcbiAgICBpZiAoYXV0b0ZvY3VzKSB7XHJcbiAgICAgIGNvbnN0IGZvY3VzYWJsZSA9IGNvbXBvbmVudFdyYXBwZXIubmF0aXZlRWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKFxyXG4gICAgICAgICdidXR0b24sIFtocmVmXSwgaW5wdXQsIHNlbGVjdCwgdGV4dGFyZWEsIFt0YWJpbmRleF06bm90KFt0YWJpbmRleD1cIi0xXCJdKSdcclxuICAgICAgKTtcclxuICAgICAgaWYgKGZvY3VzYWJsZSAmJiBmb2N1c2FibGUubGVuZ3RoKSB7XHJcbiAgICAgICAgdGhpcy5wcmV2aW91c0FjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG4gICAgICAgIGZvY3VzYWJsZVswXS5mb2N1cygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXN0b3JlcyB0aGUgbGFzdCBmb2N1cyBpcyB0aGVyZSB3YXMgb25lXHJcbiAgICovXHJcbiAgcHJpdmF0ZSByZXN0b3JlUHJldmlvdXNGb2N1cygpIHtcclxuICAgIGlmICh0aGlzLnByZXZpb3VzQWN0aXZlRWxlbWVudCkge1xyXG4gICAgICB0aGlzLnByZXZpb3VzQWN0aXZlRWxlbWVudC5mb2N1cygpO1xyXG4gICAgICB0aGlzLnByZXZpb3VzQWN0aXZlRWxlbWVudCA9IG51bGw7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb25maWd1cmUgdGhlIGFkZGluZyBhbmQgcmVtb3ZhbCBvZiBhIHdyYXBwZXIgY2xhc3MgLSBwcmVkb21pbmFudGx5IGFuaW1hdGlvbiBmb2N1c2VkXHJcbiAgICogQHBhcmFtIG9wdGlvbnNcclxuICAgKiBAcGFyYW0gbW9kYWxXcmFwcGVyRWxcclxuICAgKi9cclxuICBwcml2YXRlIHRvZ2dsZVdyYXBwZXJDbGFzcyhtb2RhbFdyYXBwZXJFbDogRWxlbWVudFJlZiwgd3JhcHBlckNsYXNzOiBzdHJpbmcpIHtcclxuICAgIGNvbnN0IHdyYXBwZXJDbGFzc0xpc3QgPSBtb2RhbFdyYXBwZXJFbC5uYXRpdmVFbGVtZW50LmNsYXNzTGlzdDtcclxuICAgIGNvbnN0IHdyYXBwZXJDbGFzc0l0ZW1zID0gd3JhcHBlckNsYXNzLnNwbGl0KCcgJyk7XHJcbiAgICBpZiAod3JhcHBlckNsYXNzTGlzdC50b1N0cmluZygpLmluZGV4T2Yod3JhcHBlckNsYXNzKSAhPT0gLTEpIHtcclxuICAgICAgd3JhcHBlckNsYXNzTGlzdC5yZW1vdmUoLi4ud3JhcHBlckNsYXNzSXRlbXMpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd3JhcHBlckNsYXNzTGlzdC5hZGQoLi4ud3JhcHBlckNsYXNzSXRlbXMpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSGVscGVyIGZ1bmN0aW9uIGZvciBhIG1vcmUgcmVhZGFibGUgdGltZW91dFxyXG4gICAqIEBwYXJhbSBtc1xyXG4gICAqL1xyXG4gIHByaXZhdGUgd2FpdChtczogbnVtYmVyID0gMCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgc2V0VGltZW91dCgoKSA9PiByZXNvbHZlKCksIG1zKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5zdHJ1Y3RzIHRoZSBob2xkZXIgdG8gcmVtb3ZlIHRoZSBtb2RhbCBhbmRcclxuICAgKiByZW1vdmVzIHRoaXMgY29tcG9uZW50IGZyb20gdGhlIGNvbGxlY3Rpb25cclxuICAgKiBAcGFyYW0ge1NpbXBsZU1vZGFsQ29tcG9uZW50fSBjb21wb25lbnRcclxuICAgKi9cclxuICBwcml2YXRlIHJlbW92ZU1vZGFsRnJvbUFycmF5KGNvbXBvbmVudCkge1xyXG4gICAgY29uc3QgaW5kZXggPSB0aGlzLm1vZGFscy5pbmRleE9mKGNvbXBvbmVudCk7XHJcbiAgICBpZiAoaW5kZXggPiAtMSkge1xyXG4gICAgICB0aGlzLnZpZXdDb250YWluZXIucmVtb3ZlKGluZGV4KTtcclxuICAgICAgdGhpcy5tb2RhbHMuc3BsaWNlKGluZGV4LCAxKTtcclxuICAgIH1cclxuICB9XHJcbn1cclxuIl19